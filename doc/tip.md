类型转换大于自动拆装箱

动态分派和静态分派



```
中间件：
redis：与memcache区别，选型？分布式锁？集群方案、简述高可用、高性能
mysql：锁、索引、集群方案
mq：kafka高性能原理
注册中心：eureka、 zk(分布式锁)

分布式事务、IO模型

Synchronized1.6后有什么改进
ReentrantLock实现原理
ConcurrentHashMap 1.7跟1.8区别
```

```
java基础，多线程，锁，bean生命周期，gc，redis过期策略以及底层存储结构
秒杀场景

一般秒杀系统，库存放redis，在redis中秒。做好容量估算，单台redisQPS大概6W-8W;
秒中了(redis拿到库存)，再发到MQ，进行异步入库
```



```
1、大文件，小内存，搜索重复KEY，TOP-N问题
比如：20G文件，每行存储一个搜索KEY，会随机重复出现，如何在单机内存1G的情况下找出TOP K的重复出现的KEY；
```



```
解法思路：分治-汇总
文件一行一行读，读到一个key往磁盘生成1个文件，文件以key命名，首次创建文件时，写入1个字符(比如1)；之后每次遇到已存在的key，则往文件再追加1个字符，最后根据文件大小排序，可得出top k；延伸：如果key重复率不高会导致大量key文件(key内存一样)，则进行下一轮迭代；读取上一轮生成的文件，根据文件容量命名新文件(比如1B、2B、3B..)，文件内容为上一轮文件的名字，最后按我文件名字排序，读取文件内存可得top k
```



```
最后问了一个场景题，他画了秒杀系统的架构，问有什么优化点。你可以百度下秒杀系统怎么做。然后保障高可用，以及一致性问题
```

```
分表分库，首先确认纬度，他说用户app查询流水，那用用户id分库。库里面有很多表，分表时再用用户id分一次，控制每张表百万级别左右
然后再分冷热数据，热数据放mysql比如最近3个月。冷数据再归档放es或者hive
等于mysql的分表分库，总容量要保证3个月单表百万级
```

```
单体应用1java进程1mysql，用户访问缓慢，怎么快速解决?
确认负载层流量，是不是用户访问量大导致。他说是
加多一台应用层机器，有无本来是单应用所以会话是有状态的，LB层使用ip_hash策略，保证同一个用户都落在同一个应用上

然后后续排查，可以dump一份内存后面分析，做代码优化或者数据库优化
```



```
wait()为什么要获得锁之后才调用?

对象头里面有哪些东西，类的结构是怎么样的?
分配的对象有哪些情况会晋升到老年代，了jvm风险分担晋升吗?
M为什么是推拉，而不直接推？为什么消息收发不直接点对点，不经服务器?

你的IM架构高度依赖redis，有考虑redis挂了的问题吗？怎么处理?即使不挂，出现网络分区怎么处理?如果降级，怎么降?
上redis之前有容量估算、运维也有监控、并且也有哨兵做高可用,redis cluster只会丢一部分数据。Redis也有自己的持久化机制进行数据恢复。

Redis集群通常是主备集群；

Redis的Sentinel组件会监视集群的状态，可能仅因为Sentinel组件所在服务器和主Redis的网络通讯出现了问题(并不是主Redis故障)，导致发现当前的“主Redis”不可用就会把“从Redis”设为“主Redis”；在做这个主备转换前后，原来已链接“老主Redis”的客户仍然在处理，新加入的链接交给了“新主Redis”，这就导致了“不一致性” ；

所以Redis在CAP中做到了AP，所以这种情况下 作为分布式锁会有问题、作为队列不能保证消息只被消费一次；
```





```
为什么需要降级和熔断
在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。比如单个服务C出现问题，服务B调用服务C就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务B瘫痪。服务与服务之间的依赖性，故障会传播，那么服务A调用服务B也会瘫痪，这样会对整个微服务系统造成灾难性的严重后果，这就会出现服务故障，叫做“雪崩”效应。
而降级或熔断的目的就是防止雪崩，停止服务之间的级联故障并提供后备选项，来提高系统的整体弹性。
当存在第三方访问调用时，这些问题会更加严重。“第三方”是一个隐藏了实施细节的“黑匣子”，可以随时更改，并且每个客户端库的网络或资源配置都不同，通常难以监控和更改，这时降级就显得更为重要了。
当然，降级也可以使用在服务内部，来实现容错或保证程序的主要功能的可用性。

```

```
降级：降级就是在主流程、主方案以外，还有planB，当主方案出现问题时，可以马上切换到planB。降级也分为自动降级和手动降级，前者是系统自动检测到问题时自动切换，后者是系统检测到问题报警，人为的切换，降级代表着系统相比降级之前其功能表现不如之前的完美。
降级往往是一个兜底方案，需要在做设计的时候结合业务场景考虑哪些环节可能会出问题，出了问题如何降级，是自动降级还是手动降级，降级后需要启用怎么样的应急处理流程等等。
一般以下情況均可采用降級方法：超时降级、异常降级、失败次数降级、拒绝服务降级、限流也是降级。


熔断：熔断一般是在服务异常或调用出现问题时，及时断掉，不再调用。就像保险丝，当达到一定电流时，保险丝熔断，保护其他电器不受损。除了服务调用异常可以熔断外，还有一种情况是，在秒杀或大促时，可以熔断一些边缘服务，从而保证下单等主要服务的可用性。
需要采用熔断的情况一般是：涉及到核心功能运行时，熔断边缘服务、服务调用异常时，配合降级方法planB，进行熔断、服务被攻击时熔断等等。
不管是降级还是熔断，都是为了保证了系统的稳定性，可用性。
```



```
聊项目的技术点，比如redis怎样保证高可用高性能，mq怎么保障一致性这些

场景题，秒杀系统
```

```
spring boot的自动装备,spring mvc流程，json接口有没有使用到viewResolve，spring里的事务传播机制结合一些场景分析,还有隔离级别,spring 有哪些后置处理器，如何编写一个starter，如何禁止一个starter，如何在一个没有注入容器中的对象中获取到bean，aop实现原理，配置变量先后顺序。。。
```

```mysql
查询冲突数据
有一张会议室预约记录表(appoint)，查询出所有会议室时间冲突的预约记录
id(预约ID) start_time(开始时间) end_time(结束时间) room_id(会议室ID) 
1 201902021400 201902021600 1 
2 201902021500 201902021600 1 
3 201902021600 201902021700 1 
--冲突会议室
SELECT
	* 
FROM
	test_room a,
	test_room b 
WHERE
	a.room_id = b.room_id 
	AND a.id != b.id 
	AND ( b.start_time BETWEEN a.start_time AND a.end_time ) UNION ALL
SELECT
	* 
FROM
	test_room a,
	test_room b 
WHERE
	a.room_id = b.room_id 
	AND a.id != b.id 
	AND ( b.end_time > a.start_time AND b.end_time < a.end_time )

java代码从list找出没有冲突的数据

代码分析存在的问题，就一道库存超卖的问题

考树的遍历了
```

```
如何禁止一个starter?

// 方案1，下面的代码段是使 DataSourceAutoConfiguration 无效：
@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration {}
// 方案2
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
// 方案3，在配置文件中配置
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

